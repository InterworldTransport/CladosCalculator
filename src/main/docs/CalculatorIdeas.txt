The Clados Calculator	[and some ideas for improvement]

version 2.0
Interworld Transport Project
Dr Alfred W Differ
Copyright © 2025 Alfred Differ. All rights reserved. 

You (Licensee) are granted a license to this documentation under the terms of the GNU Affero General Public License v3. A full copy of the license can be found bundled with the clados calculator project source code. This document is published as part of the documentation set associated with source code covered by the same license. If the license document is not bundled with this document, a verbatim copy of the license can be found at https://fsf.org/.

------------------------------------------------------------
------------------------------------------------------------
Table of Contents
	What the Calculator IS
	What the Calculator IS NOT
	Want More Detail?
	THE BOOLEAN TESTS
		Involving Monads
		Involving Nyads
	THE SIMPLE STATE TESTS
		Involving Monads
		Involving Nyads
	THE SIMPLE STATE MUTATORS
		Involving Monads
		Involving Nyads
	THE FOUR FUNCTIONS [MUTATORS]
		Addition
		Subtraction
		Multiplication
		Division
------------------------------------------------------------
------------------------------------------------------------
What the Calculator IS

The Clados Calculator started as a way to exercise the functionality of the clados library, so its initial layout was a collection of unit tests on monads. Along the way, though, it also became the tool that facilitated feature expansion in clados. The addition of multi-algebra objects (multi-monads or multi-multi-vectors as nyads) showed up between version 0.5 and the present version. Some nyad features were unclear in terms of requirements, so clados and Clados Calculator are progressing in parallel.

The Calculator's root purpose is as a four-function RPN calculator for geometric objects. Geometry is expressed as Clifford algebras, but with a twist. The number 'field' used to represent geometric magnitude has some of the same structure as the geometry, so a single algebra using complex numbers can be written as an order two nyadic. Because of this, soft typing scheme used for monads in cladosG is repeated for numbers in cladosF. That impacts how numeric operations work in the calculator.

Hard object types are largely respected for geometry by the calculator. Very little casting occurs. When it does it involves conversion between java primitives, their boxed varieties, and  cladosF ProtoN descendants acting as weights in monads. The calculator currently supports real and complex numbers in single or double precision floating point decimals. One could construct an order two nyad like a complex monad, but it isn't necessary anymore. Nyads don't contain nyads, so this approach provides better support in debugging applications using complex numbers in field theories.

Soft object types (tags) are in use to represent reference frames at run-time when it is far too late to create new static types. For example, two monads referencing tangent points for their coordinate basis sets both use Foot references, but must be able to distinguish between the feet to protect against improper comparisons and algebraic operations. Having a Foot is not enough, though. Which foot is referenced by a monad matters. Distinct objects are enough to ensure comparisons and operations are valid, but the 'boxed' strings in each Foot ensures a human reader can identify them. It's like naming points on a Euclidean plane. All labels are distinct points without having any details about the geometry of points.

A pure four-function calculator has arithmetic operations acting on pure 'scalar' magnitudes. CladosF is the package for the 'scalar' numbers. Real and Complex numbers can be imitated by zero or single generator geometric algebras, but there isn't much point in doing so if the user does not intend to assign geometric meaning to those generators. If an always-commuting number is what is needed for weights, then ProtoN children from cladosF suffice.

The basic four functions are the two familiar operations of multiplication and addition and their inverses. They mean more in a geometry calculator, though, because of geometric meanings. Only in small division algebras do the old meanings from elementary school apply.

------------------------------------------------------------
What the Calculator IS NOT

The calculator does not support a number of functions that are already handled elsewhere by better applications. Clados is intended as a library for developers of physical models. It is NOT intended to compete with teaching, presentation, scripting, and symbolic manipulation environments.

Graphical Representations
________

Graphical representations of geometry described by multivectors are relatively straightforward for algebras with a small number of generators but implementation effort quickly escalates for higher algebras and mixed signatures.  Development of such a feature would turn the application from a calculator to a presenter because the bulk of the code would be for drawing high dimensional geometry. Others tackle the effort as they wish, but we won't here.  There are already good tools available for the simpler cases. Consider Wolfram's platform.

This constraint might fall by the wayside, but only to provide a better UI for input register. For example, input of complex numbers might involve a polar representation combined with pinch, spread, and pick motions to set values.

Scripted Calculations
________

Scripted calculations involve development of a suitable programming or macro language. Since part of the purpose of the calculator is to act as a test platform for the Clados library, scripting support is a conflict of purpose. There are already suitable scripting environments for geometric algebras in other tools, so it makes more sense for Clados to be a plugin in those tools.

This constraint might fall by the wayside as the physics package gets underway. A basic geometry language for physics provides a philosophical underpinning. For example, factory objects and methods could constrain a model's geometry to enforce special relativity. Doing so might be done with a simple language with grammatical and semantic order enforced in the physical models.

Type∫etting ╒unctions
________

Print-ready layouts for well developed presentations and publications involves integration adapters for other tools already in use by the community. This author has little interest in these integrations, but is open to work others might contribute for this. One exception to this is the author's intent to develop simple save and load routines for objects in the calculator's stack. XML and JSON methods in the code are a partial step in this direction.

------------------------------------------------------------
Want More Detail?

Well... Read on… but be aware that Clados uses the class name “Monad” for multivectors. It also used “Nyad” for lists of monads. The word “multivector” is already a mouthful to say and a lot to type. Read on if you are prepared to use these terms as synonyms here.
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
------------------------------------------------------------
THE BOOLEAN TESTS Involving Monads

isReferenceMatch
________

This test takes the currently selected monad and tests it against the next one the stack below it. It should fail for monads in a nyad, but for nyads with only one monad in them, the next monad in the stack is in the next nyad. In that case the test might pass or fail.

Reference frame matches test that Algebra references point to the same actual object. Algebras with the same name that are not the same actual object in memory will not pass. If algebra references match, frame name strings are compared next. All that is necessary at this time is that the strings be the same. If they are, the numeric objects are compared. If they refer to the same Cardinal in memory, this test will pass. As with algebras, it is not enough that their names have the same string representation.	

isZero
________

This test takes the currently selected monad and tests whether the weight of each blade is zero in the sense that weights understand the term. The calculator relies upon a monad static method which punts to the weights to determine whether they are zero. In practice, this function checks each weight until it finds a nonzero one or defaults to true.	

isNilpotent
________

This test takes the currently selected monad and multiplies it by a copy of itself and then tests whether the result isZero. The calculator relies upon a monad static method to determine the result.

isIdempotent
________

This test takes a copy of the currently selected monad, multiplies it by a copy of itself, and then tests whether the result isGEqual. An initial test returns with a true result if the monad isGZero. The isGEqual method is not directly exposed to the calculator. It tests for a reference match (which must pass due to the way the product is constructed) and then checks the resulting weights one at a time. 

isScaledIdempotent
________

This test takes the currently selected monad and multiplies it by a copy of itself and then tests whether the result isGEqual to within a scalar magnitude. Initial tests exit this test with a result if the monad isGZero [=true], isIdempotent [=true], or isNilpotent [=false]. 

Once the product is formed the weights are checked one at a time until the first non-zero one is found. The original is then scaled by the inverse of that non-zero weight and tested for isIdempotent. If it is, the original monad is a scaled idempotent.

isGrade
________

This test takes the selected monad and the real number in the entry register and answers the following question. Is the monad purely of that grade? Integer entries are required for the operation to make sense, so a truncation occurs on the real input if it is not an integer. {e.g. A test against zero determines whether a monad is pure scalar.}

The calculator displays a monad's grade key, so this function isn't visually necessary. However, a monad must be able to answer the question without human inspection.

isMultiGrade
________

This test takes the currently selected monad and answers the following question. Is the monad purely of any grade? Nothing in the entry register is necessary for this function.

The calculator displays a monad's grade key, so this function isn't visually necessary. However, a monad must be able to answer the question without human inspection.

hasGrade
________

This test takes the currently selected monad and the real number in the entry register and answers the following question. Does the monad contain that grade? Integer entries are required for the operation to make sense, so a truncation occurs on the real input if it is not an integer. {e.g. A test against zero determines whether a monad has a scalar part.}

The calculator displays a monad's grade key, so this function isn't visually necessary. However, a monad must be able to answer the question without human inspection.

------------------------------------------------------------
THE BOOLEAN TESTS Involving Nyads

IsReferenceMatch [Strong/Weak]
________

These tests take the currently selected nyad and test it against the one the stack below it. It should always fail if there are any monads in either list that cannot pass a reference check with a monad in the other list. The strong test requires the existing monad lists pair up exactly. The weak form requires that the first nyad's monads pair up exactly leaving open the possibility that the second nyad has unmatched monads.

Nyad reference matching can be configured to require a match test to fail on unpaired monads that appear to share algebras because algebra names match yet the monads fail a reference match test. This switch is used to prevent nyad order increases when operations are used that should cause changes instead of concatenation.	

isMEqual
________

This test takes the currently selected nyad and compares it to the next one in the stack. A few quick exit tests are tried e.g. comparing the order of each nyad and the Foot they should share. After that the static method works through the first nyad's monad list looking for algebra matchs in the second. If one is found the two monads are tested for isGEqual. If every monad has a pair that passes, the method tests reflexivity by swapping the two nyads and doing it all again. Equality IS reflexive.

hasAlgebra
________

This test takes the currently selected monad and compares it to monads in the next nyad on the stack. If one of the monads in the next nyad uses exactly the same algebra reference this operation returns TRUE. Otherwise it returns FALSE. This operation in the calculator helps users deal with the fact that the calculator does not expose algebra references but does expose algebra names. If two algebras share a name, they need not be the same algebra when it comes to the objects involved. 

[It is best practice to avoid re-use of algebra names anywhere in a model, but clados will do nothing to encourage the good behavior.]

isScalarAt
________

This test takes the currently selected monad and its algebra and answers the following question. Is the next nyad in the stack a pure grade scalar for every monad using that algebra? Monads are tested  using isGrade().

isPScalarAt
________

This test takes the currently selected monad and its algebra and answers the following question. Is the next nyad in the stack a pure grade pscalar for every monad using that algebra? Monads are tested  using isGrade().


------------------------------------------------------------
THE SIMPLE STATE TESTS Involving Monads

whatGrade
________

This test takes the currently selected monad and outputs the result of the following question to the real field of the entry register. If the monad is of pure grade, what is it? Integer results are returned if the selected monad has a pure grade.

------------------------------------------------------------
THE SIMPLE STATE TESTS Involving Nyads

isStrong
________

This test takes the currently selected nyad and determines if its listed monads share an algebra. If so, the result would be false. If not and at least one monad exists, the result would be true.
	
isWeak
________

This test takes the currently selected nyad and determines if its listed monads share an algebra. If so and the nyad order is at least two, the result would be true. Otherwise it would be false.	

isFrame
________

This test takes the currently selected nyad and determines if its listed monads all share exactly the same algebra. 
[TODO more work has to be done on this test. It is possible a Frame will descending from a nyad and enforce this condition.]	


------------------------------------------------------------
THE SIMPLE STATE MUTATORS Involving Monads

Each monad is represented on a distinct tabbed pane within a panel representing a nyad. Each pane has on it set of buttons that represents operations specific to that particular monad. The buttons look the same on each panel, but they are not the same button objects in the calculator. They are {Edit, Save, Abort, Erase, Create}. All other monad specific mutators appear once at the top level of buttons on the calculator.

edit <|> .edit.
________

This mutator opens the fields for monad name, frame name, and those that represent magnitudes for the selected monad so they can be edited by the user. It also toggles the behavior of the edit button (shown when the button label changes to .edit. so the button will turn off the edit mode the next time. [Foot, signature, grade key, and algebra are not editable.]

Entering new numbers for editable magnitudes does not adjust the underlying monad immediately. It is possible to alter the magnitudes visible on the pane used by the monad without them being pushed to the monad. The edit button ONLY opens the option to edit the fields.

save
________

This mutator saves the fields that represent magnitudes to the selected monad. The entire array of magnitudes is assumed to have been altered, thus they are all pushed into the monad. Also saved are the contents of the monad name and frame name. If the monad panel was in edit mode, it also ends edit mode.

abort
________

This mutator aborts any changes to the fields that represent magnitudes by overwriting them with the magnitudes in the currently selected monad. The entire array of magnitudes is overwritten by information in the monad. Also overwritten are the contents of the monad name and frame name. If the monad panel was in edit mode, it also ends edit mode.

copy
________

This mutator provides a way to create a new nyad that is a deep copy of the currently selected nyad. New monads are created, but references to algebras are re-used. References to Cardinals are re-used. A copied nyad should pass a strong reference match test and an equality test yet be editable without causing its source to change.

create
________

This mutator provides the way to append a new monad with zero magnitudes to the selected nyad. The calculator provides a means to copy a reference to an existing algebra used by another monad selected while the create dialog is open. As long as an algebra chosen isn't already being used, the new monad will be appended to the original nyad's stack. If algebra re-use would occur when a monad is appended, an error results and no monad is appended. If no algebra is chosen for re-use, a new one is created based on the string provided in the dialog.

erase
________

This operation removes the currently selected monad from the nyad containing it.

gradeCrop
________

This action takes the currently selected monad and the real number from the entry register and trims all the magnitudes in the monad to zero except for those associated with the grade represented by the real number. Integer entries for the real number are required for the operation to make sense. 

[The calculator displays the magnitudes and users can edit them, so this function isn't strictly necessary. However, a monad must be able to answer the question without human inspection.]

gradeCut
________

This action is the inverted version of gradeCrop. This one trims the magnitudes to zero if they are associated with the grade represented by the real number. Integer entries are required for the same reason as gradeCrop.

------------------------------------------------------------
THE SIMPLE STATE MUTATORS Involving Nyads

Each nyad is represented on a distinct tabbed pane within a panel representing the nyad list. Each pane has on it set of buttons that represents operations specific to that particular nyad. The buttons look the same on each panel, but they are not the same button objects in the calculator. They are {Edit, Save, Abort, Erase, Create}. All other nyad specific mutators appear once at the top level of buttons on the calculator.

edit <|> .edit.
________

This mutator opens for edit purposes the nyad name. Foot and order are not editable. It also toggles the behavior of the edit button (shown when the button label changes to .edit. so the button will turn off the edit mode the next time.
save
________

This mutator saves the currently displayed nyad name overwriting its previous name. If the nyad panel was in edit mode, it also ends edit mode.

abort
________

This mutator aborts the currently displayed nyad name by overwriting it with the nyad's current name. If the nyad panel was in edit mode, it also ends edit mode.

copy
________

This mutator provides a way to create a new nyad that is a deep copy of the currently selected nyad. New monads are created, but references to algebras are re-used. References to Cardinals are re-used. A copied nyad should pass a strong reference match test and an equality test yet be editable without causing its source to change.

create
________

This mutator provides the way to append a new nyad with zero magnitudes for the single monad in its stack. The calculator provides a means to copy a reference to an existing foot used by another nyad selected while the the create dialog is open. If no foot is chosen for re-use, a new one is created based on the string provided in the dialog.

erase
________

This operation removes the currently selected nyad from the stack.


------------------------------------------------------------
THE FOUR FUNCTIONS [MUTATORS]

Addition
________

In any algebra, addition involves a pair of objects that share the same reference frame and produces another object using the same reference frame. Technically speaking, addition is a map from a pair of objects to one object, but the calculator carefully restricts the map by enforcing reference frame matches on the operands. Addition of objects not in the same algebra is treated as having no meaning.

Addition for monads follows the same rules as the addition operator defined in a Clifford algebra except for the additional reference frame checks. If the monads do not share the same algebra object, they fail the reference check. In practice, this is handled with a static method associated with the correct monad class. This method compares algebra references in the pair to ensure they are the same. At present, the method also compares frame names which act as a soft tag alias for an algebra. Finally, the method also checks the soft tag associated with the magnitudes represented by the Cardinal object. If the magnitudes reference the same Cardinal, they pass this piece of the reference frame match test. Be forewarned, though. What gets checked within this static method may change in the future as a physics library counterpart to clados is written. The purpose of the reference match test is to prevent non-physical operations from happening.

If reference frame test passes, the addition operation numerically adds magnitudes for similar blades. Multigrade results are quite possible. Results that are idempotents or nilpotents are also possible. Numeric addition occurs by delegation when the monad's operation finds similar blades and calls the correct method for adding the magnitudes in use.

The final complexity arises in defining addition for nyads within clados. Since this class is not currently constrained by well known geometric expectations, it is currently defined on a per monad basis. A nyad is essentially a list of monads, so nyad addition is defined as a similar binary map involving lists where any monad pairings from the lists that can be found that pass a reference frame match test are added in the sense of monads. Clados currently requires monads not pass a reference frame match test before they can be inserted into a nyad's list, so this ensures addition of nyads is not indeterminate. If a pairing exists between monads on each list, neither monad will pair with any other. When this is weakened in the future, addition will be avoided since it won't be clear what pair is being mapped to a result.

Finally, nyad addition does not require each nyad's monad have a corresponding pair. An assumption is made for unpaired monads where the nyad with the missing match actually has a match with a new zero scalar monad. That means nyad addition can produce a result with more monads in the list than either nyad had to start. In an extreme case with no pairs, the result will have a list that simply concatenates the lists of the two nyads. At the other extreme, the result will have exactly the same order as the nyad with the largest order because algebra pairs are found for all monads in one of the nyads. That means nyad addition as an operation ranges from list concatenation to something that looks like n-tuple addition.

Subtraction
________

In any algebra, subtraction involves an ordered pair of objects that share the same reference frame and produces another object using the same reference frame. Technically speaking, subtraction is a map from an ordered pair of objects to one object, but the calculator carefully restricts the map by enforcing reference frame matches on the operands as it does for addition.

Monad subtraction works as one would expect since it must function as an inverse function for addition. Internally, monads delegate magnitude subtractions to their cladosF elements the same way they do for addition. At no point is there a multiplication by "-1" and then an addition, though, unless it occurs deep within a JVM involving java primitives. Multiplication is a distinct operation with geometric meaning and not to be confused with addition.

Nyad subtraction does not require each nyad's monad have a corresponding pair for the same reason as with addition. The same assumption is made where a 'zero' is invented in one list to create the missing member of a pair. That means nyad subtraction is, as should be expected, an operation that ranges from list concatenation to n-tuple subtraction.

Multiplication
________

In any algebra, multiplication involves an ordered pair of objects that share a reference frame and produces another object using the same reference frame. Technically speaking, multiplication is a map from an ordered pair of objects to one object, but the calculator carefully restricts the map by enforcing reference frame matches on the operands as it does for addition.

Multiplication of monads follows the rules for multiplication defined in the objects used as magnitudes as well as the rules for multiplication in a Clifford algebra except for the additional reference frame checks. This is dictated by reasonable expectations for elements of a Clifford algebra. Reference frame checking is done the same way as for addition meaning the referenced algebras must match, frame name strings must be the same, and the magnitudes must share a reference to a Cardinal.
If reference frame tests pass, the multiplication operation numerically multiplies magnitudes and geometrically multiples blades. Multigrade results are quite possible. Idempotent and nilpotent results are too. Multiplication of multi-grade monads is distributive, so every blade in one monad is multiplied against every other blade in the other monad. Numeric multiplication occurs by delegation while blade multiplication is handled by an algebra's gproduct object. A monad's multiplication operation mostly keeps a tally of results collected from the others. The purpose of the reference frame test is most easily seen with multiplication because a single algebra object can agree with itself on how to multiply two pieces of geometry.
The final complexity arises in defining multiplication for nyads within clados. As with addition, multiplication is defined as a binary map involving lists where any monad pairings from the lists that can be found that pass a reference frame match test are multiplied in the sense of monads. For unmatched monads, an assumption is made where the nyad with the missing partner actually has a match with a unit scalar. That means nyad multiplication can produce a result with more monads in the list than either nyad had to start just like addition can. That means nyad multiplication is another operation that ranges from list concatenation to something that looks like n-tuple products involving determinants. The shared algebras keep track of all the details, though.

Division
________

In any algebra, division involves an ordered pair of objects that share a reference frame and produces another object using the same reference frame if the second member of the pair has an inverse. Technically speaking, division is a map from an ordered pair of objects to one object, but the calculator carefully restricts the map by enforcing reference frame matches on the operands along with a few other tests. Division also reveals how many have an overly simplistic understanding of both multiplication and division operations taught in elementary school and the calculator has to deal with this.

Division of monads follows the rules for inverse multiplication defined in the objects used as magnitudes and will attempt the rules for inverse multiplication in a Clifford algebra too with additional reference frame checks. Monads don't actually have methods for a division operation, though, so the complexity is being handled in the calculator. The second monad is checked a number of ways beyond the reference frame test including the list of boolean operations visible on the front of the calculator.

________
1. If the second monad is a zero scalar, it will have no inverse for a numeric reason. Zero has no multiplicative inverse. The division operation completes, however, by return the NaN value in the magnitude objects of the first monad.
________
2. If the second monad is nilpotent, it will have no inverse for geometric reasons. Nilpotents squares vanish, so they are a geometric equivalent for zero. The division operation completes, though, by returning the NaN value in the magnitude objects of the first monad.
________
3. If the second monad is idempotent, it will have no inverse for geometric reasons, but it does not behave like a zero scalar. Idempotent squares are the same idempotent, so they behave more like multiplication's identity element, yet they are not that element. To make matters worse, there is no element in an algebra to be multiplied against an idempotent that 'factors' it from the first monad, thus there is no path forward for the division operation to complete. Attempts within the calculator to divide by an idempotent will produce errors.
________
4. If the second monad is proportional to an idempotent, the proportion might have an inverse while the idempotent will not. The division operation will produce errors in this case because there is no path to completion.
________

The final complexity arises in defining division for nyads within clados. As with multiplication, it is defined as a binary map involving lists where any monad pairings from the lists that can be found that pass a reference frame match test are divided in the sense of monads. For unmatched monads, an assumption is made where the nyad with the missing partner actually has a matching unit scalar. That means nyad division can produce a result with more monads in the list than either nyad had to start just like multiplication can. That means nyad division is another operation that ranges from list concatenation to something that looks like n-tuple products involving determinants. The shared algebras keep track of all the details, though.

The seemingly special cases where division won't complete demonstrate that division isn't really about factoring a product. It is about measuring a product. A rectangle with sides A and B has an area of A*B. Dividing that area by a number C has an ambiguous meaning. Are we parting the rectangle into C pieces? Are we scaling side B by C and finding out A's magnitude by the new measure? The units that are assigned to the result of the operation would tell us because the first would have area dimensions and the second would have linear distance dimensions. When dividing by geometric elements, though, there is no ambiguity. The dimensions are part of the operation. Doing this brings with it the following limitations. Idempotents may not be used for scaling a measure. There are other things in an algebra that behave like zero. If care is taken with these possibilities, however, the division operation will delivery geometrically meaningful results.
